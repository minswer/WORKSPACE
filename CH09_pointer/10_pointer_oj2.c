/*
    포인터를 이용하여 문제를 해결하시오, 10개의 정수를 1차원 배열에 읽어 들인 후 아래 함수를 이용하여 내림차순으로
    정렬하고 출력하는 프로그램을 작성한다. 입출력은 main() 함수에서 실행하고, 정렬은 버블정렬 알고리즘을 응용한다.
    함수 sort() 내에서 배열을 사용하지 않고 포인터와 간접 연산자(*)를 사용한다.
*/

#include <stdio.h>

// swap() 함수: 두 정수의 값을 교환하는 함수
void swap(int *px, int *py) {
                        // 포인터 px와 py가 가리키는 값을 교환하기 위해 임시 변수 temp를 사용
    int temp = *px;    // px가 가리키는 값(첫 번째 값)을 temp에 저장
    *px = *py;         // py가 가리키는 값(두 번째 값)을 px가 가리키는 위치에 저장
    *py = temp;        // temp에 저장된 첫 번째 값을 py가 가리키는 위치에 저장
}

// sort() 함수: 버블정렬 알고리즘을 사용하여 내림차순으로 정렬하는 함수
void sort(int *v, int n) {
                                                    // 버블정렬 알고리즘을 사용하여 배열을 내림차순으로 정렬
    for (int i = 0; i < n - 1; i++) {               // 전체 배열을 여러 번 순회
        for (int j = 0; j < n - i - 1; j++) {       // 한 번 순회할 때마다 마지막 요소는 이미 정렬되어 있음
                                                    // v + j는 배열의 j번째 요소를 가리킴
            if (*(v + j) < *(v + j + 1)) {          // 현재 요소가 다음 요소보다 작다면
                swap(v + j, v + j + 1);             // 두 값을 교환하여 내림차순으로 정렬
            }
        }
    }
}

int main() {
    int arr[10];  // 크기가 10인 정수형 배열을 선언
    
    // 10개의 정수를 사용자로부터 입력 받기
    for (int i = 0; i < 10; i++) {
        scanf("%d", &arr[i]);  // 배열의 각 요소에 정수 입력
    }
    
    // 입력 받은 배열을 내림차순으로 정렬
    sort(arr, 10);  // 배열 arr과 배열의 크기 10을 전달하여 정렬 실행
    
    // 정렬된 배열 출력하기
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);  // 배열의 각 요소를 공백을 두고 출력
    }
    
    return 0;  
}

/*

** 버블 정렬

    버블정렬(Bubble Sort)은 가장 간단한 정렬 알고리즘 중 하나로, 
    배열이나 리스트의 원소들을 인접한 두 요소씩 비교하여 자리를 바꾸는 방식으로 정렬을 수행합니다. 
    이 알고리즘은 반복문을 통해 요소를 비교하고, 비교한 두 원소의 위치를 바꾸는 과정을 여러 번 반복하여 전체 리스트를 정렬합니다.

** 버블정렬의 동작 원리:
    1. 비교 및 교환:

        배열의 첫 번째 원소부터 시작하여, 인접한 두 원소를 비교합니다.
        만약 두 원소가 잘못된 순서(정렬하려는 순서가 아닌 경우)라면, 두 원소의 자리를 바꿉니다.
    
    2.한 번의 순회:

        배열을 처음부터 끝까지 순차적으로 확인하고, 비교한 후 자리를 바꾼다면, 가장 큰 값(내림차순 기준) 혹은 가장 작은 값(오름차순 기준)이 마지막으로 "버블처럼" 올라오게 됩니다. 그래서 이를 "버블정렬"이라고 부릅니다.
        한 번의 순회를 마친 후, 마지막 원소는 이미 정렬된 상태이므로, 다음 반복에서는 그 원소를 제외하고 다시 비교합니다.

    3.반복:

        전체 배열을 정렬할 때까지 이러한 과정을 반복합니다.
        매 반복마다 비교할 원소의 개수는 하나씩 줄어듭니다. 왜냐하면 마지막 원소가 이미 정렬되었기 때문입니다.


* 버블정렬의 동작 예시:
    배열: [5, 3, 8, 4, 2]

첫 번째 반복:

5와 3 비교 → 5가 더 크므로 자리를 바꿉니다: [3, 5, 8, 4, 2]
5와 8 비교 → 자리를 바꾸지 않습니다.
8과 4 비교 → 8이 더 크므로 자리를 바꿉니다: [3, 5, 4, 8, 2]
8과 2 비교 → 8이 더 크므로 자리를 바꿉니다: [3, 5, 4, 2, 8]
최대값 8이 마지막으로 이동: 첫 번째 반복 후 배열은 [3, 5, 4, 2, 8]입니다.


두 번째 반복:

3과 5 비교 → 자리를 바꾸지 않습니다.
5와 4 비교 → 5가 더 크므로 자리를 바꿉니다: [3, 4, 5, 2, 8]
5와 2 비교 → 5가 더 크므로 자리를 바꿉니다: [3, 4, 2, 5, 8]
두 번째로 큰 값 5가 그 자리에 고정: 배열은 [3, 4, 2, 5, 8]입니다.


세 번째 반복:

3과 4 비교 → 자리를 바꾸지 않습니다.
4와 2 비교 → 4가 더 크므로 자리를 바꿉니다: [3, 2, 4, 5, 8]
세 번째로 큰 값 4가 그 자리에 고정: 배열은 [3, 2, 4, 5, 8]입니다.


네 번째 반복:

3과 2 비교 → 3이 더 크므로 자리를 바꿉니다: [2, 3, 4, 5, 8]
최소값 2가 맨 앞에 고정: 배열은 [2, 3, 4, 5, 8]입니다.
정렬이 완료된 상태입니다.


* 시간 복잡도:
    최악의 경우 시간 복잡도: O(n²)

        버블정렬은 두 중첩된 반복문을 사용하여 요소들을 비교하고 교환하는 방식이기 때문에
        최악의 경우 (정렬되지 않은 배열에 대해서) n번 반복하고, 각 반복마다 n번의 비교를 수행하므로 시간 복잡도는 O(n²)입니다.

    최선의 경우 시간 복잡도: O(n)

    배열이 이미 정렬된 상태라면, 버블정렬은 한 번의 비교로 더 이상 교환할 것이 없다는 것을 알 수 있으므로 
    한 번의 순회만으로 종료됩니다. 이때 시간 복잡도는 O(n)입니다.


** 버블 정렬의 장점과 단점:

장점:
    구현이 매우 간단하고 이해하기 쉽습니다.
    비교적 작은 데이터셋에 대해서는 효과적일 수 있습니다.


단점:
    시간 복잡도가 O(n²)으로 매우 비효율적입니다. 큰 데이터셋을 처리하기에 적합하지 않습니다.
    다른 효율적인 알고리즘(예: 퀵정렬, 병합정렬)과 비교하면 성능이 떨어집니다.


결론:
    버블정렬은 알고리즘의 개념을 배우기에 좋지만, 실제로 성능이 중요한 경우에는 다른 정렬 알고리즘을 사용하는 것이 더 효율적입니다.
*/