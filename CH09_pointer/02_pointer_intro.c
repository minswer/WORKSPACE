#include <stdio.h>

/*
    * pointer = 포인터 변수수
        -> "변수의 메모리 주소"를 저장하는 변수 <=> 일반 변수(실제 값을 저장함)
        -> 포인터도 변수임 ->> 사용하기 전 선언이 필수
        -> 변수 앞에 * 붙여 사용함
         => 포인터 변수 선언 시에는 포인터 변수를 의미함
            ex. int *p; <@1. 포인터 변수를 의미함>
            =>> 초기화 시에는 '포인터 변수의 실제 주소에 값을 저장함'을 의미함
            ex. *p = 100; <@2. 포인터 변수의 실제 주소에 100이라는 값을 저장함  == 일반 변수>
                =>>> 그러니 어떻게 사용하냐에 따라 의미가 완전히 달라짐 

    ** 포인터 사용시 주의할 점
        -> 꼭 초기화 하고 사용할 것.(초기화를 하지 않으면 해당 메모리에 대한 잔여물이 처리되지 않아서 오류가 발생함.)
        ex. int *p;(포인터 변수 선언) int num;(일반 변수 선언)
            p = num; <@3. 포인터 변수 초기화 => num 변수의 시작 주소를 포인터 변수에 저장함> ==>> 필수적임. 꼭 해야함
            (--> 위의 *p = 100 과는 또 다른 의미임)

            -> int *p; p = num; ->> 보통 이렇게는 같이 사용함. 세트의 의미
               but. *p = 100; 이 붙으면 포인터 변수가 갖고 있는 실제 주소에 100이라는 값을 저장한다는 의미가 부여됨.

            ->> int *p; *p = 100;   -> 포인터 변수에 대한 초기화를 안해줬기에 해당 메모리에 대한 잔여물이 처리되지 않음. 
                                        따라서 오류가 발생함.
        
        -> 포인터가 아무것도 가리키지 않는 경우엔 NULL(0)로 설정함 ->> 초기화를 하지 않는 경우에 대한 해결법
            ->> NULL은 <stdio.h> 덕분에 정수 0으로 정의됨 -->> 주소 0을 엑세스 하면 시스템에서 자동적으로 오류 감지함
            ->> 포인터 사용하기 전, NULL 체크(유효성 체크)를 하면 더 안전한 코드 개발 가능
            ***  객체지향 언어엔 포인터에 대한 구체적인 문법은 없음. 객체 지향 언어에서는 대신 참조 변수 사용함
                 참조 변수 -> 주소(메모리) 

        -> 포인터 자료형과 변수의 자료형은 일치해야함
            ->> 자료형이 다르면 값의 손실이 생길 수 있음.
            ->>> 
*/

int main() {
    int a;      // 일반 변수 a(메모리: 10번지~13번지)
    int *pa;    // 포인터 변수 pa

    pa = &a;
    // pa는 포인터 변수를 의미함
    // &a는 a변수의 시작 주소를 의미함.
    // 포인터 변수 pa에 일반 변수 a의 주소(시작 주소는 10번지)를 저장함 -> 포인터 변수는 10번지가 됨

    *pa = 99;
    // *pa는 간접 참조 연산자 => 포인터 변수 pa의 저장된 주소에 99라는 실제 값을 저장함
    //  -> 포인터가 가리키는 위치의 값을 추출함
    //   -> () 다음으로 높은 우선순위를 가짐 =>> 다른 연산자보다 먼저 실행됨됨
    //    =>> *pa == a 

    printf("포인터로 a출력: %d\n", *pa);
    printf("일반 변수로 a 출력: %d\n", a);



}