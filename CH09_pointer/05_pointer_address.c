#include <stdio.h>

/*
    * 주소와 포인터 
        -> 주소는 상수 <---> 포인터는 변수 =>> 서로 반대되는 개념
        -> 상수는 대입 연산자 좌측 항에 사용 불가함
        ex. 100 = 'A'; -> (X)
            *pa = 'A'; -> (O)

        ex1. int a, b; // a=100번지, b = 200번지
            int *p;
            p = &a;
            p = &b;
            =>> a와 b의 주소는 바뀌지 않음 ->> 포인터는 a와 b가 어떤 주소를 대입하느냐에 따라 달라짐(포인터는 변수이기 때문)
                -> &a = &b; ->> (X) ->>> 각 주소는 상수이기 때문에 성립이 안됨 + 죄측항에 사용 불가

        ex2. int a;
            int *pa, *pb;
            pa = pb = &a;       => a <-> pa, pb => a라는 일반 변수를 pa,pb 라는 포인터 변가 동시에 가리킴킴

            *pa = 10;           => a값 10
            printf("%d", *pb);  => 10 출력됨 =>> a <-> pa, pb
            
            ->>> 하나의 변수를 동시에 가리키는 것 가능

    ** 포인터의 크기는 저장할 주소의 크기에 따라 결정됨
    *** 크기가 클수록 넓은 범위의 메모리를 사용 가능함
    **** 포인터의 크기는 컴파일러에 따라 다를 수 있음
    ***** 모든 주소와 포인터는 가리키는 자료형과 상관없이 주소 크기가 동일함
    (어차피 값은 항상 시작 주소만을 담으니까 -> 윈도우에서는 아래 코드 실행 결과와 같이 4byte로 표기됨.)
            
*/

int main() {
    char ch;            //1byte
    int in;             //4byte
    double db;          //8byte

    char *pc = &ch;
    int *pi = &in;
    double *pd = &db;

    printf("char형 변수의 주소 크기: %d\n", sizeof(&ch));           
    printf("int형 변수의 주소 크기: %d\n", sizeof(&in));
    printf("double형 변수의 주소 크기: %d\n", sizeof(&db));
    // 자료형의 크기가 어떻든 시작 주소의 크기만을 표기하기에 세 값이 어떻든 같음

    printf("char *포인터가 가리키는 변수의 크기: %d\n", sizeof(*pc));
    printf("int *포인터가 가리키는 변수의 크기: %d\n", sizeof(*pi));
    printf("double *포인터가 가리키는 변수의 크기: %d\n", sizeof(*pd));
    // 각각의 자료형의 크기가 다르기에 해당 포인터가 가리키는 변수의 크기 또한 다름
    // 간접참조 연산자로 쓰이기에 실제 변수의 크기와 같게 출력됨됨
}