/*
    *변수(variable) = 하나의 값을 저장하는 메모리 공간

    *배열(array) = 동일한 자료형의 데이터를 메모리에 연속적으로 저장하는 방법
        -> 변수에 다수의 값을 저장하고 싶을 때 사용함.(실질적으로는 하나의 값이 저장됌.)
        
        -1. 다른 자료형처럼 선언을 통해 저장공간 확보함
        -2. 배열의 개수와 상관없이 하나의 이름으로로 선언가능
        -3. 동일한 자료형만 넣을 수 있음.
        -4. 배열은 한번에 변수를 여려개 선언하는 것과 동일함
        -5. 배열 안의 아이템들은 0번부터 인덱스 번호를 갖음

        * 문법 : 자료형 변수명[사이즈];
        ex. int ary[5];         // 5칸짜리 정수형 배열 선언(5개짜리의 변수를 만들고 엮는다.)

        * 단점
        -1. 동일한 자료형만 저장 가능함 (int 배열을 만들었으면 int형만 가능함)
        -2. 배열은 항상 고정된 크기를 유지
            (ary[5] -> 값을 2개만 저장함 -> 3칸은 현재 사용 X  -> 그럼에도 5칸의 공간은 모두 메모리에 유지 )
        
        => 위의 단점을 보완하여 객체지향 프로그래밍 언어에서는 collection framework(자료형) 만듦. -> list, map ...

    *
*/

#include <stdio.h>

int main() {
    int ary[5];       // 100칸짜리 정수형 배열 선언
                        // -> 배열의 길이는 100
                        //  -> 배열의 index : 0 ~ 99(not 100)
                        //   -> 


    ary[0] = 10;        // qoduf 0번 칸에 10을 저장
    ary[3] = 5;         // 배열 3번 칸에 5를 저장
    ary[1] = ary[0] + ary[3];

    // & -> 포인터 
    // scanf에서 문자 배열(문자열) -> & 사용하지 않음
    // scanf에서 정수, 실수 배열 -> & 사용함함
    scanf("%d", &ary[2]);

    printf("[0]의 인덱스: %d\n", ary[0]);
    printf("[1]의 인덱스: %d\n", ary[1]);
    printf("[2]의 인덱스: %d\n", ary[2]);
    printf("[3]의 인덱스: %d\n", ary[3]);
    printf("[4]의 인덱스: %d\n", ary[4]);       
    // ary[4]에 대한 초기화를 하지 않았기에(값을 담지 않았기에) 잔여물 값 출력댐.
}